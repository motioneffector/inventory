<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/inventory - Demo</title>
  <style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html { font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif; font-size: 1rem; line-height: 1.5; color: #e6edf3; background: #0d1117; min-height: 100vh; }
:root {
  --bg-primary: #0d1117; --bg-secondary: #161b22; --bg-tertiary: #21262d; --bg-hover: #30363d;
  --border-default: #30363d; --border-muted: #21262d;
  --text-primary: #e6edf3; --text-secondary: #8b949e; --text-muted: #6e7681; --text-link: #58a6ff;
  --accent-blue: #1f6feb; --accent-blue-hover: #388bfd; --accent-green: #238636; --accent-green-bright: #3fb950;
  --accent-red: #da3633; --accent-red-bright: #f85149; --accent-yellow: #d29922; --accent-yellow-bright: #e3b341; --accent-purple: #8957e5;
  --space-xs: 4px; --space-sm: 8px; --space-md: 16px; --space-lg: 24px; --space-xl: 32px; --space-xxl: 48px;
  --radius-sm: 4px; --radius-md: 6px; --radius-lg: 8px; --radius-xl: 12px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
  --font-size-xs: 0.75rem; --font-size-sm: 0.875rem; --font-size-md: 1rem; --font-size-lg: 1.25rem; --font-size-xl: 1.5rem; --font-size-xxl: 2rem;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.3); --shadow-md: 0 4px 8px rgba(0,0,0,0.3); --shadow-lg: 0 8px 16px rgba(0,0,0,0.4);
  --transition-fast: 0.1s ease; --transition-normal: 0.2s ease; --transition-slow: 0.3s ease;
}
.page { max-width: 1200px; margin: 0 auto; padding: var(--space-xl); }
.header { margin-bottom: var(--space-xxl); padding-bottom: var(--space-xl); border-bottom: 1px solid var(--border-default); }
.header-title { font-size: var(--font-size-xxl); font-weight: 600; color: var(--text-primary); margin-bottom: var(--space-sm); }
.header-description { font-size: var(--font-size-lg); color: var(--text-secondary); margin-bottom: var(--space-lg); }
.header-links { display: flex; gap: var(--space-md); }
.header-link { display: inline-flex; align-items: center; gap: var(--space-xs); color: var(--text-link); text-decoration: none; font-size: var(--font-size-sm); padding: var(--space-xs) var(--space-sm); border-radius: var(--radius-md); transition: background var(--transition-fast); }
.header-link:hover { background: var(--bg-tertiary); text-decoration: underline; }
.exhibits { display: flex; flex-direction: column; gap: var(--space-xxl); }
.exhibit { background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: var(--radius-xl); overflow: hidden; }
.exhibit-header { padding: var(--space-lg); border-bottom: 1px solid var(--border-default); }
.exhibit-title { font-size: var(--font-size-xl); font-weight: 600; color: var(--text-primary); margin-bottom: var(--space-xs); }
.exhibit-description { font-size: var(--font-size-md); color: var(--text-secondary); }
.exhibit-content { padding: var(--space-lg); }
.exhibit-interactive { background: var(--bg-primary); border: 1px solid var(--border-muted); border-radius: var(--radius-lg); min-height: 200px; padding: var(--space-lg); margin-bottom: var(--space-lg); }
.exhibit-controls { display: flex; flex-wrap: wrap; gap: var(--space-sm); padding: var(--space-md); background: var(--bg-tertiary); border-radius: var(--radius-md); margin-bottom: var(--space-lg); align-items: center; }
.btn { display: inline-flex; align-items: center; justify-content: center; gap: var(--space-xs); padding: var(--space-sm) var(--space-md); font-size: var(--font-size-sm); font-weight: 500; border-radius: var(--radius-md); border: 1px solid transparent; cursor: pointer; transition: all var(--transition-fast); white-space: nowrap; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-primary { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }
.btn-primary:hover:not(:disabled) { background: var(--accent-blue-hover); border-color: var(--accent-blue-hover); }
.btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--border-default); }
.btn-secondary:hover:not(:disabled) { background: var(--bg-hover); }
.btn-danger { background: var(--accent-red); color: white; border-color: var(--accent-red); }
.btn-danger:hover:not(:disabled) { background: var(--accent-red-bright); }
.btn-success { background: var(--accent-green); color: white; border-color: var(--accent-green); }
.btn-success:hover:not(:disabled) { background: var(--accent-green-bright); }
.toggle { display: inline-flex; align-items: center; gap: var(--space-sm); cursor: pointer; font-size: var(--font-size-sm); }
.toggle-switch { position: relative; width: 40px; height: 22px; background: var(--bg-hover); border-radius: 11px; transition: background var(--transition-normal); }
.toggle-switch::after { content: ''; position: absolute; top: 3px; left: 3px; width: 16px; height: 16px; background: var(--text-primary); border-radius: 50%; transition: transform var(--transition-normal); }
.toggle input { display: none; }
.toggle input:checked + .toggle-switch { background: var(--accent-blue); }
.toggle input:checked + .toggle-switch::after { transform: translateX(18px); }
.toggle-label { color: var(--text-secondary); }
.test-runner { margin-top: var(--space-xxl); background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: var(--radius-xl); overflow: hidden; }
.test-runner-header { padding: var(--space-lg); border-bottom: 1px solid var(--border-default); display: flex; align-items: center; justify-content: space-between; }
.test-runner-title { font-size: var(--font-size-xl); font-weight: 600; }
.test-runner-actions { display: flex; gap: var(--space-sm); }
.test-runner-content { padding: var(--space-lg); }
.test-progress { margin-bottom: var(--space-lg); }
.test-progress-bar { height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden; margin-bottom: var(--space-sm); }
.test-progress-fill { height: 100%; background: var(--accent-blue); border-radius: 4px; transition: width var(--transition-fast); width: 0%; }
.test-progress-fill.success { background: var(--accent-green); }
.test-progress-fill.failure { background: var(--accent-red); }
.test-progress-text { font-size: var(--font-size-sm); color: var(--text-secondary); }
.test-output { background: var(--bg-primary); border: 1px solid var(--border-muted); border-radius: var(--radius-md); max-height: 400px; overflow-y: auto; font-family: var(--font-mono); font-size: var(--font-size-sm); }
.test-output-empty { padding: var(--space-xl); text-align: center; color: var(--text-muted); }
.test-item { padding: var(--space-sm) var(--space-md); border-bottom: 1px solid var(--border-muted); display: flex; align-items: flex-start; gap: var(--space-sm); }
.test-item:last-child { border-bottom: none; }
.test-icon { flex-shrink: 0; font-size: var(--font-size-md); }
.test-icon.pass { color: var(--accent-green-bright); }
.test-icon.fail { color: var(--accent-red-bright); }
.test-name { color: var(--text-primary); }
.test-error { color: var(--accent-red-bright); font-size: var(--font-size-xs); margin-top: var(--space-xs); }
.test-summary { margin-top: var(--space-lg); padding: var(--space-md); background: var(--bg-tertiary); border-radius: var(--radius-md); font-size: var(--font-size-sm); display: flex; gap: var(--space-lg); }
.test-summary-item { display: flex; align-items: center; gap: var(--space-xs); }
.test-summary-item.passed { color: var(--accent-green-bright); }
.test-summary-item.failed { color: var(--accent-red-bright); }
.test-summary-item.skipped { color: var(--text-muted); }
.hidden { display: none; }
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--border-default); }

/* Grid exhibit */
.grid-container { display: flex; gap: var(--space-lg); flex-wrap: wrap; }
.grid-panel { background: var(--bg-tertiary); border-radius: var(--radius-md); padding: var(--space-md); }
.grid-cells { display: grid; gap: 2px; background: var(--bg-hover); padding: 2px; border-radius: var(--radius-sm); }
.grid-cell { width: 36px; height: 36px; background: var(--bg-secondary); border-radius: 2px; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: all var(--transition-fast); position: relative; }
.grid-cell.occupied { background: var(--bg-tertiary); }
.grid-cell.valid-drop { background: rgba(35,134,54,0.3); box-shadow: inset 0 0 0 2px var(--accent-green); }
.grid-cell.invalid-drop { background: rgba(218,54,51,0.3); box-shadow: inset 0 0 0 2px var(--accent-red); }
.loot-pile { min-width: 150px; }
.loot-pile-title { font-size: var(--font-size-sm); font-weight: 600; color: var(--text-secondary); margin-bottom: var(--space-sm); }
.loot-item { display: flex; align-items: center; gap: var(--space-sm); padding: var(--space-sm); background: var(--bg-secondary); border-radius: var(--radius-sm); margin-bottom: var(--space-xs); cursor: grab; transition: all var(--transition-fast); border: 1px solid transparent; }
.loot-item:hover { background: var(--bg-hover); border-color: var(--border-default); }
.loot-item.highlight { animation: pulse 2s infinite; }
@keyframes pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(31,111,235,0.4); } 50% { box-shadow: 0 0 0 8px rgba(31,111,235,0); } }
.loot-item-icon { font-size: 20px; }
.loot-item-info { font-size: var(--font-size-xs); color: var(--text-secondary); }
.capacity-bar { margin-top: var(--space-md); height: 8px; background: var(--bg-hover); border-radius: 4px; overflow: hidden; }
.capacity-fill { height: 100%; background: var(--accent-blue); transition: width var(--transition-normal); }

/* Loadout exhibit */
.loadout-container { display: grid; grid-template-columns: 200px 1fr 200px; gap: var(--space-lg); }
@media (max-width: 900px) { .loadout-container { grid-template-columns: 1fr; } }
.character-panel, .backpack-panel, .chest-panel { background: var(--bg-tertiary); border-radius: var(--radius-md); padding: var(--space-md); }
.panel-title { font-size: var(--font-size-sm); font-weight: 600; color: var(--text-secondary); margin-bottom: var(--space-md); text-align: center; }
.equipment-slots { display: flex; flex-direction: column; align-items: center; gap: var(--space-sm); }
.equipment-slot { width: 50px; height: 50px; background: var(--bg-secondary); border: 2px dashed var(--border-default); border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: all var(--transition-fast); position: relative; }
.equipment-slot:hover { border-color: var(--accent-blue); }
.equipment-slot.filled { border-style: solid; border-color: var(--accent-green); background: var(--bg-tertiary); }
.equipment-slot.invalid { animation: shake 0.3s; border-color: var(--accent-red); }
@keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
.slot-label { position: absolute; bottom: -18px; font-size: var(--font-size-xs); color: var(--text-muted); }
.slot-row { display: flex; gap: var(--space-md); }
.weight-bar { margin-bottom: var(--space-md); }
.weight-bar-track { height: 20px; background: var(--bg-hover); border-radius: 10px; overflow: hidden; position: relative; }
.weight-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent-green), var(--accent-green-bright)); transition: width 0.4s ease, background 0.3s ease; border-radius: 10px; }
.weight-bar-fill.warning { background: linear-gradient(90deg, var(--accent-yellow), var(--accent-yellow-bright)); }
.weight-bar-fill.danger { background: linear-gradient(90deg, var(--accent-red), var(--accent-red-bright)); }
.weight-bar-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: var(--font-size-xs); font-weight: 600; color: var(--text-primary); text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
.inventory-list { display: flex; flex-direction: column; gap: var(--space-xs); max-height: 300px; overflow-y: auto; }
.inventory-item { display: flex; align-items: center; gap: var(--space-sm); padding: var(--space-sm); background: var(--bg-secondary); border-radius: var(--radius-sm); cursor: grab; transition: all var(--transition-fast); }
.inventory-item:hover { background: var(--bg-hover); }
.inventory-item.locked { cursor: not-allowed; }
.inventory-item.locked::after { content: 'üîí'; margin-left: auto; font-size: 12px; }
.inventory-item.nested { margin-left: var(--space-md); border-left: 2px solid var(--border-default); }
.inventory-item.highlight { box-shadow: 0 0 0 2px var(--accent-blue); animation: pulse 2s infinite; }
.item-icon { font-size: 18px; }
.item-name { font-size: var(--font-size-sm); flex: 1; }
.item-qty { font-size: var(--font-size-xs); color: var(--text-muted); }

/* Trading exhibit */
.trading-container { display: grid; grid-template-columns: 1fr auto 1fr; gap: var(--space-lg); align-items: start; }
@media (max-width: 800px) { .trading-container { grid-template-columns: 1fr; } }
.trader-panel { background: var(--bg-tertiary); border-radius: var(--radius-md); padding: var(--space-md); }
.trade-table { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: var(--space-lg); }
.trade-icon { font-size: 48px; margin-bottom: var(--space-md); }
.trade-zone { width: 120px; height: 100px; background: var(--bg-secondary); border: 2px dashed var(--border-default); border-radius: var(--radius-md); display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: var(--space-xs); padding: var(--space-sm); position: relative; }
.trade-zone-label { position: absolute; bottom: -20px; font-size: var(--font-size-xs); color: var(--text-muted); }
.trader-inventory { display: flex; flex-direction: column; gap: var(--space-xs); }
.trader-item { display: flex; align-items: center; gap: var(--space-sm); padding: var(--space-sm); background: var(--bg-secondary); border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition-fast); }
.trader-item:hover { background: var(--bg-hover); }
.trader-item.selected { background: rgba(31,111,235,0.2); box-shadow: inset 0 0 0 2px var(--accent-blue); }
.trader-item-price { margin-left: auto; font-size: var(--font-size-xs); color: var(--accent-yellow-bright); }
.trade-summary { margin-top: var(--space-lg); padding: var(--space-md); background: var(--bg-secondary); border-radius: var(--radius-md); }
.trade-offer { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); font-size: var(--font-size-sm); }
.trade-net { font-weight: 600; color: var(--accent-green-bright); }
.trade-net.negative { color: var(--accent-red-bright); }
.flying-item { position: fixed; font-size: 24px; pointer-events: none; z-index: 1000; transition: all 0.5s ease; }
.gremlin { position: fixed; font-size: 48px; z-index: 1001; animation: gremlinAppear 0.3s ease; }
@keyframes gremlinAppear { 0% { transform: scale(0) rotate(-180deg); } 100% { transform: scale(1) rotate(0deg); } }
.rewind-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(137,87,229,0.1); pointer-events: none; z-index: 999; }
.btn-pulse { animation: btnPulse 2s infinite; }
@keyframes btnPulse { 0%,100% { box-shadow: 0 0 0 0 rgba(31,111,235,0.4); } 50% { box-shadow: 0 0 0 10px rgba(31,111,235,0); } }
.speed-slider { display: flex; align-items: center; gap: var(--space-sm); font-size: var(--font-size-sm); color: var(--text-secondary); }
.speed-slider input[type="range"] { width: 80px; accent-color: var(--accent-blue); }
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">@motioneffector/inventory</h1>
      <p class="header-description">Flexible inventory management for games - from simple backpacks to Tetris-style grids</p>
      <nav class="header-links">
        <a href="https://www.npmjs.com/package/@motioneffector/inventory" class="header-link" target="_blank">üì¶ npm</a>
        <a href="https://github.com/motioneffector/inventory" class="header-link" target="_blank">üíª GitHub</a>
        <a href="https://github.com/motioneffector/inventory/wiki" class="header-link" target="_blank">üìñ Manual</a>
      </nav>
    </header>

    <main class="exhibits">
      <!-- EXHIBIT 1: TETRIS VAULT -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Tetris Vault</h2>
          <p class="exhibit-description">Grid-mode inventory with spatial placement, item sizes, rotation, and auto-arrange</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-1">
            <div class="grid-container">
              <div class="grid-panel">
                <div class="grid-cells" id="grid-cells" style="grid-template-columns: repeat(10, 36px);"></div>
                <div class="capacity-bar"><div class="capacity-fill" id="grid-capacity"></div></div>
              </div>
              <div class="grid-panel loot-pile">
                <div class="loot-pile-title">LOOT PILE</div>
                <div id="loot-items"></div>
              </div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-primary btn-pulse" id="auto-arrange">Auto-Arrange</button>
            <button class="btn btn-secondary" id="clear-grid">Clear All</button>
            <label class="toggle"><input type="checkbox" id="rotation-toggle" checked><span class="toggle-switch"></span><span class="toggle-label">Rotation</span></label>
          </div>
        </div>
      </section>

      <!-- EXHIBIT 2: ADVENTURER'S LOADOUT -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Adventurer's Loadout</h2>
          <p class="exhibit-description">Weight-based inventory, equipment slots, nested containers, and item locking</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-2">
            <div class="loadout-container">
              <div class="character-panel">
                <div class="panel-title">CHARACTER</div>
                <div class="equipment-slots">
                  <div class="equipment-slot" data-slot="head" id="slot-head"><span class="slot-label">head</span></div>
                  <div class="slot-row">
                    <div class="equipment-slot" data-slot="mainhand" id="slot-mainhand"><span class="slot-label">main</span></div>
                    <div class="equipment-slot" data-slot="offhand" id="slot-offhand"><span class="slot-label">off</span></div>
                  </div>
                  <div class="equipment-slot" data-slot="chest" id="slot-chest"><span class="slot-label">chest</span></div>
                  <div class="equipment-slot" data-slot="legs" id="slot-legs"><span class="slot-label">legs</span></div>
                  <div class="equipment-slot" data-slot="feet" id="slot-feet"><span class="slot-label">feet</span></div>
                </div>
              </div>
              <div class="backpack-panel">
                <div class="panel-title">BACKPACK</div>
                <div class="weight-bar">
                  <div class="weight-bar-track">
                    <div class="weight-bar-fill" id="weight-fill"></div>
                    <span class="weight-bar-text" id="weight-text">0/50 kg</span>
                  </div>
                </div>
                <div class="inventory-list" id="backpack-items"></div>
              </div>
              <div class="chest-panel">
                <div class="panel-title">STORAGE CHEST</div>
                <div class="inventory-list" id="chest-items"></div>
              </div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" id="lock-gold">üîí Lock Gold</button>
            <button class="btn btn-secondary" id="sort-items">Sort A-Z</button>
            <button class="btn btn-secondary" id="merge-stacks">Merge Stacks</button>
            <button class="btn btn-primary" id="snapshot">üíæ Snapshot</button>
            <button class="btn btn-secondary" id="restore" disabled>‚è™ Restore</button>
          </div>
        </div>
      </section>

      <!-- EXHIBIT 3: TIME-WARP TRADING -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Time-Warp Trading</h2>
          <p class="exhibit-description">Atomic transactions with rollback - watch trades unfold in slow motion</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-3">
            <div class="trading-container">
              <div class="trader-panel">
                <div class="panel-title">PLAYER</div>
                <div style="margin-bottom: var(--space-md); font-size: var(--font-size-lg);">üí∞ Gold: <span id="player-gold">150</span></div>
                <div class="trader-inventory" id="player-inventory"></div>
                <div style="margin-top: var(--space-md); font-size: var(--font-size-sm); color: var(--text-muted);">Weight: <span id="player-weight">0</span>/30 kg</div>
              </div>
              <div class="trade-table">
                <div class="trade-icon">ü§ù</div>
                <div class="trade-zone" id="trade-zone"><span class="trade-zone-label">Trade Area</span></div>
              </div>
              <div class="trader-panel">
                <div class="panel-title">MERCHANT</div>
                <div class="trader-inventory" id="merchant-inventory"></div>
              </div>
            </div>
            <div class="trade-summary">
              <div class="trade-offer"><span>YOUR OFFER:</span><span id="offer-items">üó°Ô∏è Rusty Sword</span></div>
              <div class="trade-offer"><span>YOU WANT:</span><span id="want-items">‚öîÔ∏è Magic Sword</span></div>
              <div class="trade-offer"><span>NET:</span><span class="trade-net" id="trade-net">-80g</span></div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-primary btn-pulse" id="execute-trade">‚ñ∂Ô∏è Execute Trade</button>
            <label class="toggle"><input type="checkbox" id="chaos-gremlin"><span class="toggle-switch"></span><span class="toggle-label">üêõ Chaos Gremlin</span></label>
            <div class="speed-slider"><span>‚è±Ô∏è Speed:</span><input type="range" id="trade-speed" min="1" max="5" value="3"></div>
            <button class="btn btn-secondary" id="reset-trade">Reset</button>
          </div>
        </div>
      </section>
    </main>

    <footer class="test-runner">
      <div class="test-runner-header">
        <h2 class="test-runner-title">Test Suite</h2>
        <div class="test-runner-actions">
          <button class="btn btn-primary" id="run-tests">Run Tests</button>
        </div>
      </div>
      <div class="test-runner-content">
        <div class="test-progress">
          <div class="test-progress-bar"><div class="test-progress-fill" id="progress-fill"></div></div>
          <div class="test-progress-text" id="progress-text">Ready to run tests</div>
        </div>
        <div class="test-output" id="test-output"><div class="test-output-empty">Click "Run Tests" to execute the test suite</div></div>
        <div class="test-summary hidden" id="test-summary">
          <div class="test-summary-item passed"><span>‚úì</span><span id="passed-count">0</span> passed</div>
          <div class="test-summary-item failed"><span>‚úó</span><span id="failed-count">0</span> failed</div>
          <div class="test-summary-item skipped"><span>‚óã</span><span id="skipped-count">0</span> skipped</div>
        </div>
      </div>
    </footer>
  </div>

  <script type="module">
// ============================================
// INVENTORY LIBRARY (INLINE)
// ============================================
class ValidationError extends Error { constructor(m) { super(m); this.name = 'ValidationError'; } }

function createInventoryManager(options = {}) {
  const containers = new Map();
  const eventListeners = { itemAdded: [], itemRemoved: [], itemTransferred: [], containerFull: [], slotChanged: [], containerRemoved: [] };
  let transactionSnapshot = null;
  const getItemWeight = options.getItemWeight || (() => 1);
  const getItemSize = options.getItemSize || (() => ({ width: 1, height: 1 }));
  const getItemStackLimit = options.getItemStackLimit || (() => options.defaultStackSize || 99);

  function validateItemWeight(itemId) {
    const weight = getItemWeight(itemId);
    if (typeof weight !== 'number' || isNaN(weight) || weight <= 0) throw new ValidationError(`Invalid weight for "${itemId}"`);
    return weight;
  }
  function validateItemSize(itemId) {
    const size = getItemSize(itemId);
    if (!size || typeof size.width !== 'number' || typeof size.height !== 'number' || size.width <= 0 || size.height <= 0)
      throw new ValidationError(`Invalid size for "${itemId}"`);
    return size;
  }

  function createContainer(id, config) {
    if (containers.has(id)) throw new ValidationError(`Container "${id}" already exists`);
    const container = { id, config, items: new Map(), lockedItems: new Set() };
    if (config.mode === 'grid') {
      container.gridState = { width: config.width, height: config.height, cells: Array.from({ length: config.height }, () => Array(config.width).fill(null)) };
    }
    if (config.mode === 'slots') {
      container.slotState = { slots: new Map(config.slots.map(s => [s, null])) };
    }
    containers.set(id, container);
  }

  function removeContainer(id) {
    if (!containers.has(id)) throw new ValidationError(`Container "${id}" does not exist`);
    fireEvent('containerRemoved', { containerId: id });
    containers.delete(id);
  }

  function listContainers() { return Array.from(containers.keys()); }
  function getContainer(id) { const c = containers.get(id); if (!c) throw new ValidationError(`Container "${id}" does not exist`); return c; }

  function getTotalQuantity(container, itemId) {
    const stacks = container.items.get(itemId);
    return stacks ? stacks.reduce((sum, s) => sum + s.quantity, 0) : 0;
  }

  function fireEvent(event, data) { eventListeners[event]?.forEach(cb => cb(data)); }

  function addItem(containerId, itemId, quantity) {
    if (quantity === 0) return { success: true, added: 0, overflow: 0 };
    const container = getContainer(containerId);
    const config = container.config;
    if (config.mode === 'unlimited') return addItemUnlimited(container, itemId, quantity);
    if (config.mode === 'count') return addItemCount(container, itemId, quantity);
    if (config.mode === 'weight') return addItemWeight(container, itemId, quantity);
    if (config.mode === 'grid') return addItemGrid(container, itemId, quantity);
    return { success: false, added: 0, overflow: quantity, reason: 'unsupported_mode' };
  }

  function addItemUnlimited(container, itemId, quantity) {
    const stacks = container.items.get(itemId) || [];
    const stackLimit = container.config.maxStackSize || getItemStackLimit(itemId);
    let remaining = quantity;
    if (container.config.allowStacking !== false) {
      for (const stack of stacks) {
        if (stack.quantity < stackLimit) { const toAdd = Math.min(stackLimit - stack.quantity, remaining); stack.quantity += toAdd; remaining -= toAdd; if (remaining === 0) break; }
      }
      while (remaining > 0) { const toAdd = Math.min(stackLimit, remaining); stacks.push({ itemId, quantity: toAdd }); remaining -= toAdd; }
    } else {
      for (let i = 0; i < quantity; i++) stacks.push({ itemId, quantity: 1 });
    }
    container.items.set(itemId, stacks);
    fireEvent('itemAdded', { containerId: container.id, itemId, quantity, newTotal: getTotalQuantity(container, itemId) });
    return { success: true, added: quantity, overflow: 0 };
  }

  function addItemCount(container, itemId, quantity) {
    const config = container.config;
    const currentCount = Array.from(container.items.values()).reduce((sum, stacks) => sum + stacks.length, 0);
    const available = config.maxCount - currentCount;
    if (available <= 0) { fireEvent('containerFull', { containerId: container.id, itemId, overflow: quantity }); return { success: false, added: 0, overflow: quantity, reason: 'count_exceeded' }; }
    const toAdd = Math.min(available, quantity);
    const stacks = container.items.get(itemId) || [];
    for (let i = 0; i < toAdd; i++) stacks.push({ itemId, quantity: 1 });
    container.items.set(itemId, stacks);
    fireEvent('itemAdded', { containerId: container.id, itemId, quantity: toAdd, newTotal: getTotalQuantity(container, itemId) });
    if (toAdd < quantity) { fireEvent('containerFull', { containerId: container.id, itemId, overflow: quantity - toAdd }); return { success: false, added: toAdd, overflow: quantity - toAdd, reason: 'count_exceeded' }; }
    return { success: true, added: toAdd, overflow: 0 };
  }

  function addItemWeight(container, itemId, quantity) {
    const config = container.config;
    const itemWeight = validateItemWeight(itemId);
    const currentWeight = getTotalWeightInternal(container);
    const availableWeight = config.maxWeight - currentWeight;
    const maxAddable = Math.floor(availableWeight / itemWeight);
    if (maxAddable === 0) { fireEvent('containerFull', { containerId: container.id, itemId, overflow: quantity }); return { success: false, added: 0, overflow: quantity, reason: 'weight_exceeded' }; }
    const toAdd = Math.min(quantity, maxAddable);
    const result = addItemUnlimited(container, itemId, toAdd);
    if (toAdd < quantity) { fireEvent('containerFull', { containerId: container.id, itemId, overflow: quantity - toAdd }); return { success: false, added: toAdd, overflow: quantity - toAdd, reason: 'weight_exceeded' }; }
    return result;
  }

  function addItemGrid(container, itemId, quantity, position) {
    validateItemSize(itemId);
    if (position) return addItemGridAt(container, itemId, quantity, position);
    const placements = findPlacements(container.id, itemId);
    if (placements.length === 0) { fireEvent('containerFull', { containerId: container.id, itemId, overflow: quantity }); return { success: false, added: 0, overflow: quantity, reason: 'no_space' }; }
    return addItemGridAt(container, itemId, quantity, placements[0]);
  }

  function addItemGridAt(container, itemId, quantity, position) {
    const size = validateItemSize(itemId);
    const { width, height } = position.rotated ? { width: size.height, height: size.width } : size;
    if (!canPlaceAtPosition(container, itemId, position)) return { success: false, added: 0, overflow: quantity, reason: 'no_space' };
    const stacks = container.items.get(itemId) || [];
    const stackIndex = stacks.length;
    stacks.push({ itemId, quantity, position });
    container.items.set(itemId, stacks);
    for (let dy = 0; dy < height; dy++) {
      for (let dx = 0; dx < width; dx++) {
        container.gridState.cells[position.y + dy][position.x + dx] = { itemId, stackIndex, isOrigin: dy === 0 && dx === 0 };
      }
    }
    fireEvent('itemAdded', { containerId: container.id, itemId, quantity, newTotal: getTotalQuantity(container, itemId) });
    return { success: true, added: quantity, overflow: 0 };
  }

  function canPlaceAtPosition(container, itemId, position) {
    if (!container.gridState) return false;
    const size = validateItemSize(itemId);
    const { width, height } = position.rotated ? { width: size.height, height: size.width } : size;
    if (position.x < 0 || position.y < 0 || position.x + width > container.gridState.width || position.y + height > container.gridState.height) return false;
    for (let dy = 0; dy < height; dy++) {
      for (let dx = 0; dx < width; dx++) {
        if (container.gridState.cells[position.y + dy][position.x + dx] !== null) return false;
      }
    }
    return true;
  }

  function addItemAt(containerId, itemId, position, quantity = 1) {
    const container = getContainer(containerId);
    if (container.config.mode !== 'grid') throw new ValidationError('addItemAt only works with grid containers');
    return addItemGrid(container, itemId, quantity, position);
  }

  function removeItem(containerId, itemId, quantity) {
    if (quantity === 0) return 0;
    const container = getContainer(containerId);
    if (container.lockedItems.has(itemId)) throw new ValidationError(`Item "${itemId}" is locked`);
    const stacks = container.items.get(itemId);
    if (!stacks || stacks.length === 0) return 0;
    let remaining = quantity, removed = 0;
    for (let i = stacks.length - 1; i >= 0 && remaining > 0; i--) {
      const stack = stacks[i];
      const toRemove = Math.min(stack.quantity, remaining);
      stack.quantity -= toRemove;
      remaining -= toRemove;
      removed += toRemove;
      if (stack.quantity === 0) {
        if (container.gridState && stack.position) clearGridPosition(container, stack.position, itemId);
        stacks.splice(i, 1);
      }
    }
    if (stacks.length === 0) container.items.delete(itemId);
    if (removed > 0) fireEvent('itemRemoved', { containerId: container.id, itemId, quantity: removed, newTotal: getTotalQuantity(container, itemId) });
    return removed;
  }

  function clearGridPosition(container, position, itemId) {
    if (!container.gridState) return;
    const size = validateItemSize(itemId);
    const { width, height } = position.rotated ? { width: size.height, height: size.width } : size;
    for (let dy = 0; dy < height; dy++) {
      for (let dx = 0; dx < width; dx++) { container.gridState.cells[position.y + dy][position.x + dx] = null; }
    }
  }

  function transfer(from, to, itemId, quantity) {
    if (quantity === 0) return { transferred: 0, overflow: 0 };
    const source = getContainer(from);
    if (source.lockedItems.has(itemId)) throw new ValidationError(`Item "${itemId}" is locked`);
    const available = getTotalQuantity(source, itemId);
    const toTransfer = Math.min(available, quantity);
    if (toTransfer === 0) return { transferred: 0, overflow: quantity };
    const addResult = addItem(to, itemId, toTransfer);
    if (addResult.added > 0) { removeItem(from, itemId, addResult.added); fireEvent('itemTransferred', { from, to, itemId, quantity: addResult.added }); }
    return { transferred: addResult.added, overflow: quantity - addResult.added };
  }

  function getContents(containerId) {
    const container = getContainer(containerId);
    const contents = [];
    for (const [itemId, stacks] of container.items) {
      const total = stacks.reduce((sum, s) => sum + s.quantity, 0);
      contents.push({ itemId, quantity: total, position: stacks[0]?.position });
    }
    return contents;
  }

  function getStacks(containerId, itemId) { const c = getContainer(containerId); return (c.items.get(itemId) || []).map(s => ({ ...s })); }
  function hasItem(containerId, itemId) { return getContainer(containerId).items.has(itemId); }
  function getQuantity(containerId, itemId) { return getTotalQuantity(getContainer(containerId), itemId); }

  function canAdd(containerId, itemId, quantity) {
    const container = getContainer(containerId);
    const config = container.config;
    if (config.mode === 'unlimited') return { canAdd: true, maxAddable: Infinity };
    if (config.mode === 'count') {
      const current = Array.from(container.items.values()).reduce((sum, stacks) => sum + stacks.length, 0);
      const remaining = config.maxCount - current;
      return remaining > 0 ? { canAdd: true, maxAddable: remaining } : { canAdd: false, maxAddable: 0, reason: 'count_exceeded' };
    }
    if (config.mode === 'weight') {
      const itemWeight = validateItemWeight(itemId);
      const currentWeight = getTotalWeightInternal(container);
      const maxAddable = Math.floor((config.maxWeight - currentWeight) / itemWeight);
      return maxAddable > 0 ? { canAdd: true, maxAddable } : { canAdd: false, maxAddable: 0, reason: 'weight_exceeded' };
    }
    if (config.mode === 'grid') {
      const placements = findPlacements(containerId, itemId);
      return placements.length > 0 ? { canAdd: true, maxAddable: placements.length } : { canAdd: false, maxAddable: 0, reason: 'no_space' };
    }
    return { canAdd: false, maxAddable: 0, reason: 'unsupported_mode' };
  }

  function findItem(itemId) {
    const results = [];
    for (const container of containers.values()) {
      const qty = getTotalQuantity(container, itemId);
      if (qty > 0) results.push({ containerId: container.id, quantity: qty });
    }
    return results;
  }

  function getTotalWeightInternal(container) {
    let weight = 0;
    for (const [itemId, stacks] of container.items) {
      const itemWeight = validateItemWeight(itemId);
      weight += stacks.reduce((sum, s) => sum + s.quantity, 0) * itemWeight;
    }
    return weight;
  }

  function getTotalWeight(containerId) { return getTotalWeightInternal(getContainer(containerId)); }

  function getRemainingCapacity(containerId) {
    const container = getContainer(containerId);
    const config = container.config;
    if (config.mode === 'unlimited') return { type: 'unlimited' };
    if (config.mode === 'count') { const current = Array.from(container.items.values()).reduce((sum, stacks) => sum + stacks.length, 0); return { type: 'count', remaining: config.maxCount - current }; }
    if (config.mode === 'weight') { return { type: 'weight', remaining: config.maxWeight - getTotalWeightInternal(container) }; }
    if (config.mode === 'grid') {
      let occupied = 0;
      for (const row of container.gridState.cells) for (const cell of row) if (cell !== null) occupied++;
      return { type: 'cells', remaining: config.width * config.height - occupied };
    }
    return { type: 'unlimited' };
  }

  function isEmpty(containerId) { return getContainer(containerId).items.size === 0; }

  function getGrid(containerId) {
    const container = getContainer(containerId);
    if (!container.gridState) throw new ValidationError('Container is not in grid mode');
    const result = [];
    for (let y = 0; y < container.gridState.height; y++) {
      const row = [];
      for (let x = 0; x < container.gridState.width; x++) {
        const cell = container.gridState.cells[y][x];
        if (cell === null) row.push(null);
        else {
          const stacks = container.items.get(cell.itemId);
          const stack = stacks?.[cell.stackIndex];
          row.push({ itemId: cell.itemId, quantity: stack?.quantity || 0, isOrigin: cell.isOrigin });
        }
      }
      result.push(row);
    }
    return result;
  }

  function findPlacements(containerId, itemId) {
    const container = getContainer(containerId);
    if (!container.gridState) return [];
    const config = container.config;
    const size = validateItemSize(itemId);
    const placements = [];
    for (let y = 0; y <= container.gridState.height - size.height; y++) {
      for (let x = 0; x <= container.gridState.width - size.width; x++) {
        if (canPlaceAtPosition(container, itemId, { x, y, rotated: false })) placements.push({ x, y, rotated: false });
      }
    }
    if (config.allowRotation && size.width !== size.height) {
      for (let y = 0; y <= container.gridState.height - size.width; y++) {
        for (let x = 0; x <= container.gridState.width - size.height; x++) {
          if (canPlaceAtPosition(container, itemId, { x, y, rotated: true })) placements.push({ x, y, rotated: true });
        }
      }
    }
    return placements;
  }

  function setSlot(containerId, slot, itemId) {
    const container = getContainer(containerId);
    if (!container.slotState) throw new ValidationError('Container is not in slots mode');
    if (!container.slotState.slots.has(slot)) throw new ValidationError(`Slot "${slot}" does not exist`);
    const config = container.config;
    if (itemId !== null && config.slotFilters?.[slot] && !config.slotFilters[slot](itemId)) throw new ValidationError(`Item cannot be equipped in slot "${slot}"`);
    const oldItem = container.slotState.slots.get(slot);
    container.slotState.slots.set(slot, itemId);
    fireEvent('slotChanged', { containerId: container.id, slot, oldItem, newItem: itemId });
    return oldItem;
  }

  function getSlot(containerId, slot) { const c = getContainer(containerId); if (!c.slotState) throw new ValidationError('Not slots mode'); return c.slotState.slots.get(slot) || null; }
  function getAllSlots(containerId) { const c = getContainer(containerId); if (!c.slotState) throw new ValidationError('Not slots mode'); return Object.fromEntries(c.slotState.slots); }
  function clearSlot(containerId, slot) { setSlot(containerId, slot, null); }
  function canEquip(containerId, slot, itemId) {
    const c = getContainer(containerId);
    if (!c.slotState) return { canAdd: false, maxAddable: 0, reason: 'not_slots_container' };
    if (!c.slotState.slots.has(slot)) return { canAdd: false, maxAddable: 0, reason: 'slot_not_found' };
    const filter = c.config.slotFilters?.[slot];
    if (filter && !filter(itemId)) return { canAdd: false, maxAddable: 0, reason: 'slot_filter_failed' };
    return { canAdd: true, maxAddable: 1 };
  }

  function lockItem(containerId, itemId) { getContainer(containerId).lockedItems.add(itemId); }
  function unlockItem(containerId, itemId) { getContainer(containerId).lockedItems.delete(itemId); }

  function transaction(fn) {
    transactionSnapshot = serialize();
    try { fn(); transactionSnapshot = null; }
    catch (error) { deserialize(transactionSnapshot); transactionSnapshot = null; throw error; }
  }

  function sort(containerId, compareFn) {
    const container = getContainer(containerId);
    const contents = getContents(containerId);
    contents.sort(compareFn);
    const newItems = new Map();
    for (const entry of contents) {
      const oldStacks = container.items.get(entry.itemId) || [];
      newItems.set(entry.itemId, oldStacks);
    }
    container.items = newItems;
  }

  function autoArrange(containerId) {
    const container = getContainer(containerId);
    if (container.config.mode !== 'grid') throw new ValidationError('autoArrange only works with grid');
    const items = [];
    for (const [itemId, stacks] of container.items) {
      for (const stack of stacks) items.push({ itemId, quantity: stack.quantity });
    }
    container.items.clear();
    for (let y = 0; y < container.gridState.height; y++) for (let x = 0; x < container.gridState.width; x++) container.gridState.cells[y][x] = null;
    for (const item of items) addItem(containerId, item.itemId, item.quantity);
  }

  function consolidate(containerId) {
    const container = getContainer(containerId);
    for (const [itemId, stacks] of container.items) {
      const total = stacks.reduce((sum, s) => sum + s.quantity, 0);
      container.items.set(itemId, [{ itemId, quantity: total }]);
    }
  }

  function mergeStacks(containerId, itemId, fromIndex, toIndex) {
    const c = getContainer(containerId);
    const stacks = c.items.get(itemId);
    if (!stacks || !stacks[fromIndex] || !stacks[toIndex]) throw new ValidationError('Stack not found');
    stacks[toIndex].quantity += stacks[fromIndex].quantity;
    stacks.splice(fromIndex, 1);
  }

  function splitStack(containerId, itemId, fromIndex, count) {
    const c = getContainer(containerId);
    const stacks = c.items.get(itemId);
    if (!stacks || !stacks[fromIndex]) throw new ValidationError('Stack not found');
    if (stacks[fromIndex].quantity < count) throw new ValidationError('Insufficient quantity');
    stacks[fromIndex].quantity -= count;
    stacks.push({ itemId, quantity: count });
  }

  function on(event, callback) { eventListeners[event]?.push(callback); return () => { const idx = eventListeners[event]?.indexOf(callback); if (idx >= 0) eventListeners[event].splice(idx, 1); }; }

  function serialize() {
    const serialized = [];
    for (const container of containers.values()) {
      serialized.push({
        id: container.id, config: container.config,
        items: Array.from(container.items.entries()).map(([itemId, stacks]) => ({ itemId, stacks: stacks.map(s => ({ quantity: s.quantity, position: s.position })) })),
        lockedItems: Array.from(container.lockedItems),
        slotState: container.slotState ? { slots: Array.from(container.slotState.slots.entries()) } : undefined
      });
    }
    return { containers: serialized };
  }

  function deserialize(data) {
    containers.clear();
    for (const cd of data.containers) {
      createContainer(cd.id, cd.config);
      const container = getContainer(cd.id);
      for (const itemData of cd.items) {
        for (const stackData of itemData.stacks) {
          if (stackData.position) addItemAt(cd.id, itemData.itemId, stackData.position, stackData.quantity);
          else addItem(cd.id, itemData.itemId, stackData.quantity);
        }
      }
      for (const itemId of cd.lockedItems) lockItem(cd.id, itemId);
      if (cd.slotState) for (const [slot, itemId] of cd.slotState.slots) if (itemId) setSlot(cd.id, slot, itemId);
    }
  }

  function serializeContainer(containerId) {
    const container = getContainer(containerId);
    return {
      id: container.id, config: container.config,
      items: Array.from(container.items.entries()).map(([itemId, stacks]) => ({ itemId, stacks: stacks.map(s => ({ quantity: s.quantity, position: s.position })) })),
      lockedItems: Array.from(container.lockedItems)
    };
  }

  return { createContainer, removeContainer, listContainers, addItem, addItemAt, removeItem, transfer, getContents, getStacks, hasItem, getQuantity, canAdd, findItem, getTotalWeight, getRemainingCapacity, isEmpty, getGrid, findPlacements, setSlot, getSlot, getAllSlots, clearSlot, canEquip, splitStack, mergeStacks, consolidate, lockItem, unlockItem, transaction, sort, autoArrange, on, serialize, deserialize, serializeContainer };
}

// ============================================
// ITEM DEFINITIONS
// ============================================
const ITEMS = {
  gem: { icon: 'üíé', name: 'Gem', size: { width: 1, height: 1 }, weight: 0.5 },
  sword: { icon: '‚öîÔ∏è', name: 'Sword', size: { width: 1, height: 3 }, weight: 5 },
  shield: { icon: 'üõ°Ô∏è', name: 'Shield', size: { width: 2, height: 2 }, weight: 8 },
  bow: { icon: 'üèπ', name: 'Bow', size: { width: 3, height: 1 }, weight: 3 },
  scroll: { icon: 'üìú', name: 'Scroll', size: { width: 1, height: 1 }, weight: 0.2 },
  helmet: { icon: 'ü™ñ', name: 'Helmet', size: { width: 2, height: 1 }, weight: 4 },
  potion: { icon: 'üß™', name: 'Potion', size: { width: 1, height: 1 }, weight: 0.5 },
  gold: { icon: 'üí∞', name: 'Gold', size: { width: 1, height: 1 }, weight: 0.1 },
  bread: { icon: 'üçû', name: 'Bread', size: { width: 1, height: 1 }, weight: 0.3 },
  armor: { icon: 'ü•ã', name: 'Armor', size: { width: 2, height: 2 }, weight: 12 },
  pants: { icon: 'üëñ', name: 'Pants', size: { width: 1, height: 2 }, weight: 3 },
  boots: { icon: 'üë¢', name: 'Boots', size: { width: 1, height: 1 }, weight: 2 },
  rustySword: { icon: 'üó°Ô∏è', name: 'Rusty Sword', size: { width: 1, height: 2 }, weight: 4 },
  magicSword: { icon: '‚öîÔ∏è', name: 'Magic Sword', size: { width: 1, height: 3 }, weight: 3, price: 100 },
  steelShield: { icon: 'üõ°Ô∏è', name: 'Steel Shield', size: { width: 2, height: 2 }, weight: 10, price: 75 },
  elixir: { icon: 'üß™', name: 'Elixir', size: { width: 1, height: 1 }, weight: 0.5, price: 50 },
  spellScroll: { icon: 'üìú', name: 'Scroll', size: { width: 1, height: 1 }, weight: 0.1, price: 25 },
  plateHelm: { icon: 'ü™ñ', name: 'Plate Helm', size: { width: 2, height: 1 }, weight: 6, slotType: 'head' },
  plateArmor: { icon: 'ü•ã', name: 'Plate Armor', size: { width: 2, height: 2 }, weight: 15, slotType: 'chest' },
  longbow: { icon: 'üèπ', name: 'Longbow', size: { width: 1, height: 3 }, weight: 4 },
  manaPotion: { icon: 'üß™', name: 'Mana Pot', size: { width: 1, height: 1 }, weight: 0.5 },
  ruby: { icon: 'üíé', name: 'Ruby', size: { width: 1, height: 1 }, weight: 0.3 },
  emerald: { icon: 'üíé', name: 'Emerald', size: { width: 1, height: 1 }, weight: 0.3 }
};

// ============================================
// EXHIBIT 1: TETRIS VAULT
// ============================================
const gridManager = createInventoryManager({
  getItemSize: (id) => ITEMS[id]?.size || { width: 1, height: 1 },
  getItemWeight: (id) => ITEMS[id]?.weight || 1
});

const GRID_WIDTH = 10, GRID_HEIGHT = 8;
let lootPile = ['gem', 'sword', 'shield', 'bow', 'scroll', 'helmet'];
let rotationEnabled = true;
let draggingItem = null;

function initGridExhibit() {
  gridManager.createContainer('vault', { mode: 'grid', width: GRID_WIDTH, height: GRID_HEIGHT, allowRotation: true });
  // Pre-populate with scattered items
  gridManager.addItemAt('vault', 'sword', { x: 0, y: 0, rotated: false });
  gridManager.addItemAt('vault', 'shield', { x: 3, y: 2, rotated: false });
  gridManager.addItemAt('vault', 'gem', { x: 6, y: 0, rotated: false });
  gridManager.addItemAt('vault', 'bow', { x: 7, y: 3, rotated: false });
  renderGrid();
  renderLootPile();
}

function renderGrid() {
  const container = document.getElementById('grid-cells');
  container.innerHTML = '';
  const grid = gridManager.getGrid('vault');
  for (let y = 0; y < GRID_HEIGHT; y++) {
    for (let x = 0; x < GRID_WIDTH; x++) {
      const cell = document.createElement('div');
      cell.className = 'grid-cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      const gridCell = grid[y][x];
      if (gridCell && gridCell.isOrigin) {
        cell.textContent = ITEMS[gridCell.itemId]?.icon || '?';
        cell.classList.add('occupied');
        cell.draggable = true;
        cell.dataset.itemId = gridCell.itemId;
      } else if (gridCell) {
        cell.classList.add('occupied');
      }
      cell.addEventListener('dragover', handleGridDragOver);
      cell.addEventListener('drop', handleGridDrop);
      cell.addEventListener('dragleave', handleGridDragLeave);
      cell.addEventListener('dragstart', handleGridDragStart);
      container.appendChild(cell);
    }
  }
  updateCapacityBar();
}

function renderLootPile() {
  const container = document.getElementById('loot-items');
  container.innerHTML = '';
  lootPile.forEach((itemId, i) => {
    const item = ITEMS[itemId];
    const el = document.createElement('div');
    el.className = 'loot-item' + (i === 0 ? ' highlight' : '');
    el.draggable = true;
    el.dataset.itemId = itemId;
    el.innerHTML = `<span class="loot-item-icon">${item.icon}</span><div><div class="item-name">${item.name}</div><div class="loot-item-info">${item.size.width}x${item.size.height}</div></div>`;
    el.addEventListener('dragstart', handleLootDragStart);
    container.appendChild(el);
  });
}

function updateCapacityBar() {
  const cap = gridManager.getRemainingCapacity('vault');
  const total = GRID_WIDTH * GRID_HEIGHT;
  const used = total - cap.remaining;
  document.getElementById('grid-capacity').style.width = (used / total * 100) + '%';
}

function handleLootDragStart(e) {
  draggingItem = { itemId: e.target.dataset.itemId, fromLoot: true };
  e.dataTransfer.effectAllowed = 'move';
}

function handleGridDragStart(e) {
  const itemId = e.target.dataset.itemId;
  if (!itemId) return;
  draggingItem = { itemId, fromGrid: true, x: parseInt(e.target.dataset.x), y: parseInt(e.target.dataset.y) };
  e.dataTransfer.effectAllowed = 'move';
}

function handleGridDragOver(e) {
  e.preventDefault();
  if (!draggingItem) return;
  const x = parseInt(e.target.dataset.x), y = parseInt(e.target.dataset.y);
  clearDropHighlights();
  const placements = gridManager.findPlacements('vault', draggingItem.itemId);
  const valid = placements.some(p => p.x === x && p.y === y);
  highlightCells(x, y, draggingItem.itemId, valid);
}

function handleGridDragLeave() { clearDropHighlights(); }

function handleGridDrop(e) {
  e.preventDefault();
  if (!draggingItem) return;
  const x = parseInt(e.target.dataset.x), y = parseInt(e.target.dataset.y);
  clearDropHighlights();
  if (draggingItem.fromGrid) {
    gridManager.removeItem('vault', draggingItem.itemId, 1);
  }
  const result = gridManager.addItemAt('vault', draggingItem.itemId, { x, y, rotated: false });
  if (result.success) {
    if (draggingItem.fromLoot) {
      lootPile = lootPile.filter(id => id !== draggingItem.itemId);
      renderLootPile();
    }
  } else if (draggingItem.fromGrid) {
    gridManager.addItemAt('vault', draggingItem.itemId, { x: draggingItem.x, y: draggingItem.y, rotated: false });
  }
  draggingItem = null;
  renderGrid();
}

function highlightCells(x, y, itemId, valid) {
  const size = ITEMS[itemId]?.size || { width: 1, height: 1 };
  for (let dy = 0; dy < size.height; dy++) {
    for (let dx = 0; dx < size.width; dx++) {
      const cell = document.querySelector(`.grid-cell[data-x="${x+dx}"][data-y="${y+dy}"]`);
      if (cell) cell.classList.add(valid ? 'valid-drop' : 'invalid-drop');
    }
  }
}

function clearDropHighlights() {
  document.querySelectorAll('.grid-cell').forEach(c => c.classList.remove('valid-drop', 'invalid-drop'));
}

document.getElementById('auto-arrange').addEventListener('click', () => {
  gridManager.autoArrange('vault');
  renderGrid();
  document.getElementById('auto-arrange').classList.remove('btn-pulse');
});

document.getElementById('clear-grid').addEventListener('click', () => {
  const contents = gridManager.getContents('vault');
  contents.forEach(item => {
    gridManager.removeItem('vault', item.itemId, item.quantity);
    if (!lootPile.includes(item.itemId)) lootPile.push(item.itemId);
  });
  renderGrid();
  renderLootPile();
});

document.getElementById('rotation-toggle').addEventListener('change', (e) => { rotationEnabled = e.target.checked; });

// ============================================
// EXHIBIT 2: ADVENTURER'S LOADOUT
// ============================================
const loadoutManager = createInventoryManager({
  getItemWeight: (id) => ITEMS[id]?.weight || 1,
  getItemSize: (id) => ITEMS[id]?.size || { width: 1, height: 1 }
});

let savedSnapshot = null;
let goldLocked = false;

function initLoadoutExhibit() {
  loadoutManager.createContainer('backpack', { mode: 'weight', maxWeight: 50, allowStacking: true });
  loadoutManager.createContainer('chest', { mode: 'unlimited', allowStacking: true });
  loadoutManager.createContainer('equipment', {
    mode: 'slots',
    slots: ['head', 'mainhand', 'offhand', 'chest', 'legs', 'feet'],
    slotFilters: {
      head: (id) => ['helmet', 'plateHelm'].includes(id),
      mainhand: (id) => ['sword', 'rustySword', 'magicSword'].includes(id),
      offhand: (id) => ['shield', 'steelShield'].includes(id),
      chest: (id) => ['armor', 'plateArmor'].includes(id),
      legs: (id) => ['pants'].includes(id),
      feet: (id) => ['boots'].includes(id)
    }
  });
  // Pre-populate backpack (~70% weight)
  loadoutManager.addItem('backpack', 'rustySword', 1);
  loadoutManager.addItem('backpack', 'potion', 12);
  loadoutManager.addItem('backpack', 'gold', 47);
  loadoutManager.addItem('backpack', 'bread', 5);
  loadoutManager.addItem('backpack', 'ruby', 3);
  loadoutManager.addItem('backpack', 'emerald', 2);
  // Pre-equip some gear
  loadoutManager.setSlot('equipment', 'head', 'helmet');
  loadoutManager.setSlot('equipment', 'mainhand', 'rustySword');
  loadoutManager.setSlot('equipment', 'chest', 'armor');
  // Chest has better gear
  loadoutManager.addItem('chest', 'gold', 500);
  loadoutManager.addItem('chest', 'magicSword', 1);
  loadoutManager.addItem('chest', 'plateHelm', 1);
  loadoutManager.addItem('chest', 'manaPotion', 20);
  loadoutManager.addItem('chest', 'longbow', 1);
  renderLoadout();
}

function renderLoadout() {
  renderBackpack();
  renderChest();
  renderEquipment();
  updateWeightBar();
}

function renderBackpack() {
  const container = document.getElementById('backpack-items');
  container.innerHTML = '';
  const contents = loadoutManager.getContents('backpack');
  contents.forEach(entry => {
    const item = ITEMS[entry.itemId];
    const el = document.createElement('div');
    el.className = 'inventory-item' + (goldLocked && entry.itemId === 'gold' ? ' locked' : '');
    el.draggable = !(goldLocked && entry.itemId === 'gold');
    el.dataset.itemId = entry.itemId;
    el.dataset.source = 'backpack';
    el.innerHTML = `<span class="item-icon">${item?.icon || '?'}</span><span class="item-name">${item?.name || entry.itemId}</span><span class="item-qty">x${entry.quantity}</span>`;
    el.addEventListener('dragstart', handleLoadoutDragStart);
    container.appendChild(el);
  });
}

function renderChest() {
  const container = document.getElementById('chest-items');
  container.innerHTML = '';
  const contents = loadoutManager.getContents('chest');
  contents.forEach((entry, i) => {
    const item = ITEMS[entry.itemId];
    const el = document.createElement('div');
    el.className = 'inventory-item' + (entry.itemId === 'plateHelm' ? ' highlight' : '');
    el.draggable = true;
    el.dataset.itemId = entry.itemId;
    el.dataset.source = 'chest';
    if (entry.itemId === 'plateHelm') el.title = 'Drag me to upgrade!';
    el.innerHTML = `<span class="item-icon">${item?.icon || '?'}</span><span class="item-name">${item?.name || entry.itemId}</span><span class="item-qty">x${entry.quantity}</span>`;
    el.addEventListener('dragstart', handleLoadoutDragStart);
    container.appendChild(el);
  });
}

function renderEquipment() {
  const slots = loadoutManager.getAllSlots('equipment');
  for (const [slot, itemId] of Object.entries(slots)) {
    const el = document.getElementById('slot-' + slot);
    if (el) {
      el.innerHTML = `<span class="slot-label">${slot}</span>`;
      if (itemId) {
        el.innerHTML = ITEMS[itemId]?.icon || '?' + el.innerHTML;
        el.classList.add('filled');
      } else {
        el.classList.remove('filled');
      }
    }
  }
}

function updateWeightBar() {
  const weight = loadoutManager.getTotalWeight('backpack');
  const maxWeight = 50;
  const pct = (weight / maxWeight) * 100;
  const fill = document.getElementById('weight-fill');
  fill.style.width = pct + '%';
  fill.className = 'weight-bar-fill' + (pct > 90 ? ' danger' : pct > 70 ? ' warning' : '');
  document.getElementById('weight-text').textContent = `${weight.toFixed(1)}/${maxWeight} kg`;
}

let loadoutDragging = null;

function handleLoadoutDragStart(e) {
  loadoutDragging = { itemId: e.target.dataset.itemId, source: e.target.dataset.source };
  e.dataTransfer.effectAllowed = 'move';
}

document.querySelectorAll('.equipment-slot').forEach(slot => {
  slot.addEventListener('dragover', (e) => { e.preventDefault(); slot.style.borderColor = 'var(--accent-blue)'; });
  slot.addEventListener('dragleave', () => { slot.style.borderColor = ''; });
  slot.addEventListener('drop', (e) => {
    e.preventDefault();
    slot.style.borderColor = '';
    if (!loadoutDragging) return;
    const slotName = slot.dataset.slot;
    const result = loadoutManager.canEquip('equipment', slotName, loadoutDragging.itemId);
    if (result.canAdd) {
      const oldItem = loadoutManager.setSlot('equipment', slotName, loadoutDragging.itemId);
      loadoutManager.removeItem(loadoutDragging.source, loadoutDragging.itemId, 1);
      if (oldItem) loadoutManager.addItem('backpack', oldItem, 1);
      renderLoadout();
    } else {
      slot.classList.add('invalid');
      setTimeout(() => slot.classList.remove('invalid'), 300);
    }
    loadoutDragging = null;
  });
});

['backpack-items', 'chest-items'].forEach(containerId => {
  document.getElementById(containerId).addEventListener('dragover', (e) => e.preventDefault());
  document.getElementById(containerId).addEventListener('drop', (e) => {
    e.preventDefault();
    if (!loadoutDragging) return;
    const target = containerId === 'backpack-items' ? 'backpack' : 'chest';
    if (loadoutDragging.source !== target) {
      const result = loadoutManager.transfer(loadoutDragging.source, target, loadoutDragging.itemId, 1);
      renderLoadout();
    }
    loadoutDragging = null;
  });
});

document.getElementById('lock-gold').addEventListener('click', () => {
  goldLocked = !goldLocked;
  if (goldLocked) loadoutManager.lockItem('backpack', 'gold');
  else loadoutManager.unlockItem('backpack', 'gold');
  document.getElementById('lock-gold').textContent = goldLocked ? 'üîì Unlock Gold' : 'üîí Lock Gold';
  renderLoadout();
});

document.getElementById('sort-items').addEventListener('click', () => {
  loadoutManager.sort('backpack', (a, b) => a.itemId.localeCompare(b.itemId));
  renderLoadout();
});

document.getElementById('merge-stacks').addEventListener('click', () => {
  loadoutManager.consolidate('backpack');
  renderLoadout();
});

document.getElementById('snapshot').addEventListener('click', () => {
  savedSnapshot = loadoutManager.serialize();
  document.getElementById('restore').disabled = false;
  document.body.style.animation = 'flash 0.2s';
  setTimeout(() => document.body.style.animation = '', 200);
});

document.getElementById('restore').addEventListener('click', () => {
  if (savedSnapshot) {
    loadoutManager.deserialize(savedSnapshot);
    renderLoadout();
  }
});

// ============================================
// EXHIBIT 3: TIME-WARP TRADING
// ============================================
const tradeManager = createInventoryManager({
  getItemWeight: (id) => ITEMS[id]?.weight || 1
});

let playerOffer = ['rustySword'];
let playerWant = ['magicSword'];
let tradeInProgress = false;

function initTradingExhibit() {
  tradeManager.createContainer('player', { mode: 'weight', maxWeight: 30, allowStacking: true });
  tradeManager.createContainer('merchant', { mode: 'unlimited', allowStacking: true });
  tradeManager.addItem('player', 'rustySword', 1);
  tradeManager.addItem('player', 'potion', 3);
  tradeManager.addItem('player', 'gold', 150);
  tradeManager.addItem('merchant', 'magicSword', 1);
  tradeManager.addItem('merchant', 'steelShield', 1);
  tradeManager.addItem('merchant', 'elixir', 1);
  tradeManager.addItem('merchant', 'spellScroll', 1);
  renderTrading();
}

function renderTrading() {
  renderPlayerInventory();
  renderMerchantInventory();
  updateTradeSummary();
  document.getElementById('player-gold').textContent = tradeManager.getQuantity('player', 'gold');
  document.getElementById('player-weight').textContent = tradeManager.getTotalWeight('player').toFixed(1);
}

function renderPlayerInventory() {
  const container = document.getElementById('player-inventory');
  container.innerHTML = '';
  const contents = tradeManager.getContents('player').filter(e => e.itemId !== 'gold');
  contents.forEach(entry => {
    const item = ITEMS[entry.itemId];
    const el = document.createElement('div');
    el.className = 'trader-item' + (playerOffer.includes(entry.itemId) ? ' selected' : '');
    el.dataset.itemId = entry.itemId;
    el.innerHTML = `<span class="item-icon">${item?.icon || '?'}</span><span class="item-name">${item?.name || entry.itemId}</span>`;
    el.addEventListener('click', () => toggleOffer(entry.itemId));
    container.appendChild(el);
  });
}

function renderMerchantInventory() {
  const container = document.getElementById('merchant-inventory');
  container.innerHTML = '';
  const contents = tradeManager.getContents('merchant');
  contents.forEach(entry => {
    const item = ITEMS[entry.itemId];
    const el = document.createElement('div');
    el.className = 'trader-item' + (playerWant.includes(entry.itemId) ? ' selected' : '');
    el.dataset.itemId = entry.itemId;
    el.innerHTML = `<span class="item-icon">${item?.icon || '?'}</span><span class="item-name">${item?.name || entry.itemId}</span><span class="trader-item-price">${item?.price || 25}g</span>`;
    el.addEventListener('click', () => toggleWant(entry.itemId));
    container.appendChild(el);
  });
}

function toggleOffer(itemId) {
  if (playerOffer.includes(itemId)) playerOffer = playerOffer.filter(id => id !== itemId);
  else playerOffer.push(itemId);
  renderTrading();
}

function toggleWant(itemId) {
  if (playerWant.includes(itemId)) playerWant = playerWant.filter(id => id !== itemId);
  else playerWant.push(itemId);
  renderTrading();
}

function updateTradeSummary() {
  const offerText = playerOffer.map(id => ITEMS[id]?.icon || '?').join(' ') || '-';
  const wantText = playerWant.map(id => ITEMS[id]?.icon || '?').join(' ') || '-';
  document.getElementById('offer-items').textContent = offerText;
  document.getElementById('want-items').textContent = wantText;
  const wantCost = playerWant.reduce((sum, id) => sum + (ITEMS[id]?.price || 25), 0);
  const offerValue = playerOffer.reduce((sum, id) => sum + (ITEMS[id]?.price || 10), 0);
  const net = offerValue - wantCost;
  const netEl = document.getElementById('trade-net');
  netEl.textContent = (net >= 0 ? '+' : '') + net + 'g';
  netEl.className = 'trade-net' + (net < 0 ? ' negative' : '');
}

async function executeTrade() {
  if (tradeInProgress || playerWant.length === 0) return;
  tradeInProgress = true;
  document.getElementById('execute-trade').disabled = true;
  const speed = 6 - parseInt(document.getElementById('trade-speed').value);
  const baseDelay = speed * 200;
  const chaosEnabled = document.getElementById('chaos-gremlin').checked;
  const tradeZone = document.getElementById('trade-zone');
  const wantCost = playerWant.reduce((sum, id) => sum + (ITEMS[id]?.price || 25), 0);
  const offerValue = playerOffer.reduce((sum, id) => sum + (ITEMS[id]?.price || 10), 0);
  const goldNeeded = wantCost - offerValue;

  try {
    tradeManager.transaction(() => {
      // Remove offered items
      playerOffer.forEach(id => tradeManager.removeItem('player', id, 1));
      // Pay gold if needed
      if (goldNeeded > 0) tradeManager.removeItem('player', 'gold', goldNeeded);
      // Simulate delay/failure point
      if (chaosEnabled) throw new Error('Chaos Gremlin strikes!');
      // Add wanted items
      playerWant.forEach(id => {
        tradeManager.removeItem('merchant', id, 1);
        tradeManager.addItem('player', id, 1);
      });
      // Add offered items to merchant
      playerOffer.forEach(id => tradeManager.addItem('merchant', id, 1));
      // Give gold to merchant
      if (goldNeeded > 0) tradeManager.addItem('merchant', 'gold', goldNeeded);
    });
    // Success animation
    tradeZone.style.background = 'rgba(35, 134, 54, 0.3)';
    await sleep(baseDelay);
    playerOffer = [];
    playerWant = [];
  } catch (e) {
    // Failure - show rewind
    tradeZone.style.background = 'rgba(218, 54, 51, 0.3)';
    const gremlin = document.createElement('div');
    gremlin.className = 'gremlin';
    gremlin.textContent = 'üêõ';
    gremlin.style.left = '50%';
    gremlin.style.top = '50%';
    gremlin.style.transform = 'translate(-50%, -50%)';
    document.body.appendChild(gremlin);
    await sleep(baseDelay);
    gremlin.remove();
  }

  tradeZone.style.background = '';
  tradeInProgress = false;
  document.getElementById('execute-trade').disabled = false;
  document.getElementById('execute-trade').classList.remove('btn-pulse');
  renderTrading();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

document.getElementById('execute-trade').addEventListener('click', executeTrade);

document.getElementById('reset-trade').addEventListener('click', () => {
  tradeManager.removeContainer('player');
  tradeManager.removeContainer('merchant');
  playerOffer = ['rustySword'];
  playerWant = ['magicSword'];
  initTradingExhibit();
  document.getElementById('execute-trade').classList.add('btn-pulse');
});

// ============================================
// TEST RUNNER
// ============================================
const testRunner = {
  tests: [],
  results: [],
  running: false,
  register(name, fn) { this.tests.push({ name, fn }); },
  async run() {
    if (this.running) return;
    this.running = true;
    this.results = [];
    const output = document.getElementById('test-output');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const summary = document.getElementById('test-summary');
    const runBtn = document.getElementById('run-tests');
    runBtn.disabled = true;
    output.innerHTML = '';
    summary.classList.add('hidden');
    progressFill.style.width = '0%';
    progressFill.className = 'test-progress-fill';
    let passed = 0, failed = 0;
    for (let i = 0; i < this.tests.length; i++) {
      const test = this.tests[i];
      const progress = ((i + 1) / this.tests.length) * 100;
      progressFill.style.width = `${progress}%`;
      progressText.textContent = `Running: ${test.name}`;
      try {
        await test.fn();
        passed++;
        this.results.push({ name: test.name, passed: true });
        output.innerHTML += `<div class="test-item"><span class="test-icon pass">‚úì</span><span class="test-name">${escapeHtml(test.name)}</span></div>`;
      } catch (e) {
        failed++;
        this.results.push({ name: test.name, passed: false, error: e.message });
        output.innerHTML += `<div class="test-item"><span class="test-icon fail">‚úó</span><div><div class="test-name">${escapeHtml(test.name)}</div><div class="test-error">${escapeHtml(e.message)}</div></div></div>`;
      }
      output.scrollTop = output.scrollHeight;
      await new Promise(r => setTimeout(r, 10));
    }
    progressFill.classList.add(failed === 0 ? 'success' : 'failure');
    progressText.textContent = `Complete: ${passed}/${this.tests.length} passed`;
    document.getElementById('passed-count').textContent = passed;
    document.getElementById('failed-count').textContent = failed;
    document.getElementById('skipped-count').textContent = 0;
    summary.classList.remove('hidden');
    runBtn.disabled = false;
    this.running = false;
  }
};

function escapeHtml(str) { return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }

document.getElementById('run-tests').addEventListener('click', () => testRunner.run());

// Register tests
testRunner.register('creates manager with default options', () => {
  const m = createInventoryManager();
  if (!m) throw new Error('Manager not created');
});

testRunner.register('creates unlimited container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  if (!m.listContainers().includes('test')) throw new Error('Container not found');
});

testRunner.register('adds items to unlimited container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  const result = m.addItem('test', 'item1', 5);
  if (!result.success) throw new Error('Add failed');
  if (m.getQuantity('test', 'item1') !== 5) throw new Error('Wrong quantity');
});

testRunner.register('removes items from container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 10);
  const removed = m.removeItem('test', 'item1', 3);
  if (removed !== 3) throw new Error('Wrong removed count');
  if (m.getQuantity('test', 'item1') !== 7) throw new Error('Wrong remaining');
});

testRunner.register('creates count-limited container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'count', maxCount: 5 });
  m.addItem('test', 'item1', 3);
  m.addItem('test', 'item2', 2);
  const result = m.addItem('test', 'item3', 1);
  if (result.success) throw new Error('Should have failed');
  if (result.reason !== 'count_exceeded') throw new Error('Wrong reason');
});

testRunner.register('creates weight-limited container', () => {
  const m = createInventoryManager({ getItemWeight: () => 2 });
  m.createContainer('test', { mode: 'weight', maxWeight: 10 });
  m.addItem('test', 'item1', 3); // 6 weight
  const result = m.addItem('test', 'item2', 3); // needs 6 more, only 4 available
  if (result.added !== 2) throw new Error('Should add partial: ' + result.added);
});

testRunner.register('creates grid container', () => {
  const m = createInventoryManager({ getItemSize: () => ({ width: 1, height: 1 }) });
  m.createContainer('test', { mode: 'grid', width: 5, height: 5 });
  const grid = m.getGrid('test');
  if (grid.length !== 5) throw new Error('Wrong height');
  if (grid[0].length !== 5) throw new Error('Wrong width');
});

testRunner.register('places items in grid', () => {
  const m = createInventoryManager({ getItemSize: () => ({ width: 2, height: 2 }) });
  m.createContainer('test', { mode: 'grid', width: 5, height: 5 });
  const result = m.addItemAt('test', 'item1', { x: 0, y: 0, rotated: false });
  if (!result.success) throw new Error('Add failed');
  const grid = m.getGrid('test');
  if (!grid[0][0]) throw new Error('Cell should be occupied');
});

testRunner.register('finds placements in grid', () => {
  const m = createInventoryManager({ getItemSize: () => ({ width: 1, height: 1 }) });
  m.createContainer('test', { mode: 'grid', width: 3, height: 3 });
  const placements = m.findPlacements('test', 'item1');
  if (placements.length !== 9) throw new Error('Should find 9 placements');
});

testRunner.register('grid rejects overlapping items', () => {
  const m = createInventoryManager({ getItemSize: () => ({ width: 2, height: 2 }) });
  m.createContainer('test', { mode: 'grid', width: 3, height: 3 });
  m.addItemAt('test', 'item1', { x: 0, y: 0, rotated: false });
  const result = m.addItemAt('test', 'item2', { x: 1, y: 1, rotated: false });
  if (result.success) throw new Error('Should reject overlap');
});

testRunner.register('creates slots container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'slots', slots: ['head', 'chest', 'feet'] });
  const slots = m.getAllSlots('test');
  if (!('head' in slots)) throw new Error('Missing head slot');
});

testRunner.register('equips items to slots', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'slots', slots: ['head'], slotFilters: { head: (id) => id === 'helmet' } });
  const old = m.setSlot('test', 'head', 'helmet');
  if (old !== null) throw new Error('Should return null for empty slot');
  if (m.getSlot('test', 'head') !== 'helmet') throw new Error('Slot not set');
});

testRunner.register('slot filters reject invalid items', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'slots', slots: ['head'], slotFilters: { head: (id) => id === 'helmet' } });
  try {
    m.setSlot('test', 'head', 'sword');
    throw new Error('Should have rejected');
  } catch (e) {
    if (!e.message.includes('cannot be equipped')) throw e;
  }
});

testRunner.register('transfers items between containers', () => {
  const m = createInventoryManager();
  m.createContainer('a', { mode: 'unlimited' });
  m.createContainer('b', { mode: 'unlimited' });
  m.addItem('a', 'item1', 10);
  const result = m.transfer('a', 'b', 'item1', 5);
  if (result.transferred !== 5) throw new Error('Wrong transfer count');
  if (m.getQuantity('a', 'item1') !== 5) throw new Error('Wrong source qty');
  if (m.getQuantity('b', 'item1') !== 5) throw new Error('Wrong dest qty');
});

testRunner.register('locks items prevent removal', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 5);
  m.lockItem('test', 'item1');
  try {
    m.removeItem('test', 'item1', 1);
    throw new Error('Should have thrown');
  } catch (e) {
    if (!e.message.includes('locked')) throw e;
  }
});

testRunner.register('unlocks items allow removal', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 5);
  m.lockItem('test', 'item1');
  m.unlockItem('test', 'item1');
  const removed = m.removeItem('test', 'item1', 1);
  if (removed !== 1) throw new Error('Should remove after unlock');
});

testRunner.register('transactions roll back on error', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 10);
  try {
    m.transaction(() => {
      m.removeItem('test', 'item1', 5);
      throw new Error('Simulated failure');
    });
  } catch (e) {}
  if (m.getQuantity('test', 'item1') !== 10) throw new Error('Should rollback');
});

testRunner.register('transactions commit on success', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 10);
  m.transaction(() => {
    m.removeItem('test', 'item1', 5);
  });
  if (m.getQuantity('test', 'item1') !== 5) throw new Error('Should commit');
});

testRunner.register('serializes and deserializes state', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 7);
  const data = m.serialize();
  m.removeContainer('test');
  m.deserialize(data);
  if (m.getQuantity('test', 'item1') !== 7) throw new Error('Should restore');
});

testRunner.register('fires itemAdded events', () => {
  const m = createInventoryManager();
  let fired = false;
  m.on('itemAdded', (e) => { fired = true; });
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 1);
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('fires itemRemoved events', () => {
  const m = createInventoryManager();
  let fired = false;
  m.on('itemRemoved', (e) => { fired = true; });
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 5);
  m.removeItem('test', 'item1', 1);
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('fires containerFull events', () => {
  const m = createInventoryManager();
  let fired = false;
  m.on('containerFull', (e) => { fired = true; });
  m.createContainer('test', { mode: 'count', maxCount: 1 });
  m.addItem('test', 'item1', 1);
  m.addItem('test', 'item2', 1);
  if (!fired) throw new Error('Event not fired');
});

testRunner.register('hasItem returns true for existing items', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 1);
  if (!m.hasItem('test', 'item1')) throw new Error('Should have item');
});

testRunner.register('hasItem returns false for missing items', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  if (m.hasItem('test', 'item1')) throw new Error('Should not have item');
});

testRunner.register('isEmpty returns true for empty container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  if (!m.isEmpty('test')) throw new Error('Should be empty');
});

testRunner.register('isEmpty returns false for non-empty container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 1);
  if (m.isEmpty('test')) throw new Error('Should not be empty');
});

testRunner.register('getContents returns all items', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'item1', 3);
  m.addItem('test', 'item2', 5);
  const contents = m.getContents('test');
  if (contents.length !== 2) throw new Error('Wrong item count');
});

testRunner.register('getRemainingCapacity for count mode', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'count', maxCount: 10 });
  m.addItem('test', 'item1', 3);
  const cap = m.getRemainingCapacity('test');
  if (cap.remaining !== 7) throw new Error('Wrong capacity');
});

testRunner.register('getRemainingCapacity for weight mode', () => {
  const m = createInventoryManager({ getItemWeight: () => 2 });
  m.createContainer('test', { mode: 'weight', maxWeight: 20 });
  m.addItem('test', 'item1', 3);
  const cap = m.getRemainingCapacity('test');
  if (cap.remaining !== 14) throw new Error('Wrong capacity: ' + cap.remaining);
});

testRunner.register('canAdd returns correct maxAddable', () => {
  const m = createInventoryManager({ getItemWeight: () => 5 });
  m.createContainer('test', { mode: 'weight', maxWeight: 20 });
  const result = m.canAdd('test', 'item1', 10);
  if (result.maxAddable !== 4) throw new Error('Wrong maxAddable');
});

testRunner.register('findItem locates items across containers', () => {
  const m = createInventoryManager();
  m.createContainer('a', { mode: 'unlimited' });
  m.createContainer('b', { mode: 'unlimited' });
  m.addItem('a', 'item1', 5);
  m.addItem('b', 'item1', 3);
  const found = m.findItem('item1');
  if (found.length !== 2) throw new Error('Should find in both');
});

testRunner.register('autoArrange repacks grid items', () => {
  const m = createInventoryManager({ getItemSize: () => ({ width: 1, height: 1 }) });
  m.createContainer('test', { mode: 'grid', width: 3, height: 3 });
  m.addItemAt('test', 'item1', { x: 2, y: 2, rotated: false });
  m.autoArrange('test');
  const grid = m.getGrid('test');
  if (!grid[0][0] || grid[0][0].itemId !== 'item1') throw new Error('Should move to 0,0');
});

testRunner.register('sort orders items alphabetically', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.addItem('test', 'zebra', 1);
  m.addItem('test', 'apple', 1);
  m.addItem('test', 'mango', 1);
  m.sort('test', (a, b) => a.itemId.localeCompare(b.itemId));
  const contents = m.getContents('test');
  if (contents[0].itemId !== 'apple') throw new Error('Should be sorted');
});

testRunner.register('consolidate merges stacks', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited', allowStacking: true });
  m.addItem('test', 'item1', 3);
  m.addItem('test', 'item1', 5);
  m.consolidate('test');
  const stacks = m.getStacks('test', 'item1');
  if (stacks.length !== 1) throw new Error('Should consolidate to 1 stack');
  if (stacks[0].quantity !== 8) throw new Error('Wrong total quantity');
});

testRunner.register('throws on duplicate container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  try {
    m.createContainer('test', { mode: 'unlimited' });
    throw new Error('Should throw');
  } catch (e) {
    if (!e.message.includes('already exists')) throw e;
  }
});

testRunner.register('throws on non-existent container', () => {
  const m = createInventoryManager();
  try {
    m.addItem('nonexistent', 'item', 1);
    throw new Error('Should throw');
  } catch (e) {
    if (!e.message.includes('does not exist')) throw e;
  }
});

testRunner.register('removeContainer deletes container', () => {
  const m = createInventoryManager();
  m.createContainer('test', { mode: 'unlimited' });
  m.removeContainer('test');
  if (m.listContainers().includes('test')) throw new Error('Should be removed');
});

testRunner.register('grid rotation finds more placements', () => {
  const m = createInventoryManager({ getItemSize: (id) => id === 'tall' ? { width: 1, height: 3 } : { width: 1, height: 1 } });
  m.createContainer('test', { mode: 'grid', width: 3, height: 1, allowRotation: true });
  const placements = m.findPlacements('test', 'tall');
  if (placements.length === 0) throw new Error('Should find rotated placement');
  if (!placements.some(p => p.rotated)) throw new Error('Should include rotated');
});

// ============================================
// INITIALIZE EXHIBITS
// ============================================
initGridExhibit();
initLoadoutExhibit();
initTradingExhibit();
  </script>
</body>
</html>
